import numpy as np
from scipy.linalg import eigh
import os
base_dir = os.path.dirname(os.path.abspath(__file__))
import matplotlib.pyplot as plt
import pandas as pd
from scipy import interpolate
from scipy.integrate import solve_ivp
from scipy.signal import cont2discrete, welch, sosfiltfilt, tf2sos

# ISO 2631 Wk filter (Rimell et al., 2007)
def build_iso_wk(fs):
    """
    Build the ISO 2631 Wk frequency weighting filter for vibration comfort analysis.
    
    This function creates a digital approximation of the Wk filter described in 
    ISO 2631 (Rimell et al., 2007), which is used to weight vertical acceleration 
    signals according to human sensitivity in the time domain for visualisation only.
    
    Add description of filter?

    Parameters:
    fs : float
    fs is the Sampling frequency [Hz] of the digital signal to be filtered.

    Returns:
    sections : list of tuple
    List of tuples containing coefficients of each second-order section
    in discrete-time (digital) form. Each tuple corresponds to 
    a filter stage: high-pass, low-pass, transition, and step.

    Notes
    -----
    The Wk filter is designed to weight vertical accelerations such that
    vibrations in frequency ranges most sensitive to human discomfort 
    in a seated position are emphasized.
    """
    f1, Q1 = 0.4, 0.5
    f2, Q2 = 100.0, 0.5
    f3, f4 = 12.5, 12.5
    f5, Q5, f6, Q6 = 2.37, 0.91, 3.3, 0.91

    w1, w2, w3, w4, w5, w6 = [2*np.pi*f for f in [f1, f2, f3, f4, f5, f6]]
    sections = []

    # High-pass Hh
    num = [1.0, 0.0, 0.0]
    den = [1.0, w1/Q1, w1**2]
    znum, zden, _ = cont2discrete((num, den), 1/fs, method='bilinear')
    sections.append((znum.flatten(), zden.flatten()))

    # Low-pass Hl
    num = [0.0, 0.0, w2**2]
    den = [1.0, w2/Q2, w2**2]
    znum, zden, _ = cont2discrete((num, den), 1/fs, method='bilinear')
    sections.append((znum.flatten(), zden.flatten()))

    # Transition Ht
    num = [0.0, w3, w3*w4]
    den = [1.0, w4, w4**2]
    znum, zden, _ = cont2discrete((num, den), 1/fs, method='bilinear')
    sections.append((znum.flatten(), zden.flatten()))

    # Step Hs
    num = [1.0, w5/Q5, w5**2]
    den = [1.0, w6/Q6, w6**2]
    znum, zden, _ = cont2discrete((num, den), 1/fs, method='bilinear')
    sections.append((znum.flatten(), zden.flatten()))

    return sections
def comfort_classification(a_rms):
    """
    Classify human comfort level based on ISO 2631 weighted RMS acceleration
    for visualisation

    Parameters:
    a_rms : float
    a_rms is the ISO-weighted RMS vertical acceleration [m/s²] of the sprung mass.

    Returns:
    comfort_level : str
    comfort_level is the comfort classification 
    according to ISO 2631 thresholds
    """
    if a_rms < 0.315: return "Not uncomfortable"
    elif a_rms < 0.63: return "A little uncomfortable"
    elif a_rms < 1.0: return "Fairly uncomfortable"
    elif a_rms < 1.6: return "Uncomfortable"
    elif a_rms < 2.5: return "Very uncomfortable"
    else: return "Extremely uncomfortable"
    
def k_finder(f_target, m_s, m_u, k_t):
    """
    Finds the suspension stiffness k_s required to achieve a target sprung-mass 
    natural frequency in a 2-DOF quarter-car model.

    This function finds the best suspension stiffness k_s such that 
    sprung mass mode of the 2DOF system is equivalent to the target 
    natural frequency f_target
    The unsprung mass mode is ignored as only the eigenvector
    with the highest participation from the sprung mass is used.
    The solution is obtained using a Secant method root-finder.

    Parameters:
    f_target : float
    Target natural frequency of the sprung-mass mode [Hz].
    m_s : float
    The percentage of sprung mass which acts on the rear wheel  [kg].
    m_u : float
    Unsprung mass of the rear wheel[kg].
    k_t : float
    Tire stiffness [N/m].

    Returns:
    k_s_opt : float
    The suspension stiffness [N/m] that matches the target frequency 
    for the sprung-mass mode.

    Notes
    -----
    - The eigenproblem K φ = λ M φ yields λ = ω² and ω = 2πf.
    - The mode with maximum participation at the sprung-mass DOF (index 0)
      is selected as the “sprung” mode.
    - The Secant method iteratively solves f_mode(k_s) - f_target = 0.

    """
    m_total=m_u+m_s 
    """
    below is an estimate of the spring stiffness for a target frequency using
    1DOF model this estimate is used to determine an interval of
    reasonable intial guesses to be used within the Secant method"""
    k_estimate = (2 * np.pi * f_target)**2 * m_total
    k_s_lower = 0.5 * k_estimate
    k_s_higher = 2 * k_estimate
    
    def rf_func(k_s):
        """
        This functions provides the residual function
        = actual_sprung_mode_frequency - target_frequency
        to be used in the Secant solver. 
        The secant solver will then find the root of this 
        equation which corresponds to a k_s value which 
        gives a frequency equivalent
        to the target sprung-mass frequency f_target
     
               
        Parameters: 
        k_s : float
        The suspension stiffness [N/m] that matches the target 
        frequency for the sprung-mass mode.
        
        Returns: 
        actual_frequency - target_frequency
        This allows the secant method to find k_s such that
        this residual function equals zero
        """
        #Build stiffness matrix K
        K = np.array([[k_s, -k_s],  
                      [-k_s, k_s + k_t]])
        #Build mass matirx M
        M = np.array([[m_s, 0],  
                      [0, m_u]])
        
        # Solve generalized eigenvalue problem K φ = λ M φ
        
        eigenvalues, eigenvectors = eigh(K, M)
        
        #From solutions extract natural frequency
        omega_squared = eigenvalues
        omega = np.sqrt(omega_squared)
        #Convert to Hz
        freq = omega / (2 * np.pi)
        
        participations = np.abs(eigenvectors[0,:])  # sprung mass DOF is index 0
        mode_index = np.argmax(participations)      # mode with largest sprung participation
        f_mode = freq[mode_index] # Sprung mass mode (lower frequency)
        
        return f_mode - f_target

    """
    Secant method implementation
    """
    #Initial guesses from 1DOF model
    k_s_last, k_s_curr = k_s_lower, k_s_higher
    #Compute the residual functions fo these guesses
    F_last, F_curr = rf_func(k_s_last), rf_func(k_s_curr)

    max_iterations = 50 
    tolerance = 1e-4  # Hz tolerance for convergence


    #Secant Loop
    for i in range(max_iterations):
        # Check convergence if frequency error is small enough
        if abs(F_curr) < tolerance:
            break
        
        #Safe-Guard to prevent dividing by 0
        safe_gd = F_curr - F_last
        if abs(safe_gd) < 1e-12:
            safe_gd = np.sign(safe_gd) * 1e-12
        
        #Secant update approximating derivative
        k_s_new = k_s_curr - F_curr * (k_s_curr - k_s_last) / safe_gd
        
        # Ensure positive stiffness
        if k_s_new <= 0:
            k_s_new = 1e-3
        
        # Update for next iteration
        k_s_last, F_last = k_s_curr, F_curr
        k_s_curr, F_curr = k_s_new, rf_func(k_s_new)
        
    else:
        print('✗ NO CONVERGENCE')
   #rename final k_s_curr to k_s_opt for clarity     
    k_s_opt=k_s_curr
    
    return k_s_opt

def c_finder(k_opt, zeta_target, M, k_t):
    """
    Finds the rear-wheel damping c_s required to achieve a target sprung-mass 
    modal damping ratio in a 2-DOF quarter-car model.

    This function finds the best suspension damping c_s such that 
    sprung mass mode of the 2DOF system is equivalent to the target 
    modal damping ratio zeta_target.
    
    The model uses state-space analysis, eigenvalue decomposition, and a Secant 
    method root-finder to match the desired modal damping.
    
    The unsprung mass mode is ignored as only the eigenvector
    with the highest participation from the sprung mass is used.
    The solution is obtained using a Secant method root-finder with added
    clamped step sizes to prevent divergence.

    Parameters:
    k_opt: float
    The optimal spring stiffness value already found [N/m]
    zeta_target : float
    Target modal damping ratio of the sprung-mass mode [Hz].
    M : ndarray(2X2)
    The Mass Matrix of the quarter car system
    k_t : float
    Tire stiffness [N/m].

    Returns:
    c_s_opt : float
    The suspension damping [N/m] that matches the modal damping ratio
    for the sprung-mass mode.

    Notes
    """
    def rf_func2(k_s, c_s):
        """
        Residual function used to calculate the modal damping of the 
        sprung-mass mode for a given suspension damping c_s.

        The function constructs the state-space matrix:
          A = [[ 0      I ],
                 [-M⁻¹K  -M⁻¹C]].
        in order to convert the second-order differential equations into first-order differential
        
        Eigenvalues of A gives the system’s modal decay rates and 
        damped natural frequencies: λ = σ ± j ω_d

        The sprung-mass mode is identified as the eigenvector with the largest 
        participation in the sprung-mass displacement DOF (index 0).  
        
        The sprung-mass modal damping ratio is calculated: δ = -σ / sqrt(σ² + ω_d²)
        The returned residual is: residual = δ_actual − δ_target to be used
        by the Secant Method.
        Where the root found = correct damping c_s.

        Parameters:
        k_s : float
        Suspension stiffness [N/m].
        c_s : float
        suspension damping [N·s/m].

        Returns:
        Modal Damping Ratio 
        """
        #Build stiffness Matrix
        K = np.array([[k_s, -k_s],
                      [-k_s, k_s + k_t]])
        #Build Damping Matrix
        C = np.array([[c_s, -c_s],
                      [-c_s, c_s]])
        #Compute the inverse of Mass Matrix
        M_inv = np.linalg.inv(M)
        
        #Build State-Space Matrix
        A = np.block([[np.zeros((2,2)), np.eye(2)],
                      [-M_inv @ K, -M_inv @ C]])
        
        #Solve eignevalue problem λv=Av
        eigvals, eigvecs = np.linalg.eig(A)
        
        #Calculate Mode Participation
        n_sprung = 1    
        participations = []
        for i in range(eigvecs.shape[1]):
            # Only consider the position entries for sprung mass
            P = np.sum(np.abs(eigvecs[0:n_sprung, i]))
            participations.append(P)
        
        #Pick mode with largest sprung mass participation ---
        if len(participations) == 0:
            # Fallback if no modes found
            return 0.0
        mode_index = np.argmax(participations)
        lam_mode = eigvals[mode_index]
        
        #Find Decay rate and natural frequency
        sigma = np.real(lam_mode)
        omega_d = np.imag(lam_mode)
        
        # Avoid division by zero
        if np.isclose(sigma**2 + omega_d**2, 0.0):
            zeta = 0.0
        else:
            #Compute modal damping ratio
            zeta = -sigma / np.sqrt(sigma**2 + omega_d**2)
        return zeta

    def objective_func(c_s):
        """Residual for Secant method: (actual damping − target damping)."""
        return rf_func2(k_s_opt, c_s)- zeta_target
    

    """
    Secant Method Implementation
    """
    #Initial Bounds based on reasonable values for a motorcycle spring
    c_lower, c_upper = 500, 1500 

    #Initial Guess inputed
    c_last, c_curr = c_lower, c_upper
    #Computed residuals for intial guess
    F_last, F_curr = objective_func(c_last), objective_func(c_curr)

    max_step=500 # Clamped step size to prevent divergence
    
    #Secant Loop
    for i in range(50):
        
        #Check convergence
    #(converges if damping ratio error is small enough)
        if abs(F_curr) < 1e-4:  # Tolerance on damping ratio
            break
        #Safe-Guard- prevent division by 0
        safe_gd = F_curr - F_last
        if abs(safe_gd) < 1e-12:
            safe_gd = np.sign(safe_gd) * 1e-12
        #Secant Updates by approximating derivative 
        c_new = c_curr - F_curr * (c_curr - c_last) / safe_gd
        step = c_new - c_curr
        #Clamp step size to avoid divergence
        if abs(step) > max_step:
            step = np.sign(step) * max_step
        c_new = c_curr + step
        
       # Prevent unphysical or NaN values
        if np.isnan(c_new) or np.isinf(c_new):
            print("Warning: secant produced invalid c_s, stopping iteration")
            break
        
        #Shift Values
        c_last, F_last = c_curr, F_curr
        c_curr, F_curr = c_new, objective_func(c_new)
    #Set final result to c_s_opt
    c_s_opt = c_curr
    return c_s_opt

def road_analysis(k_s_opt, c_s_opt, roads, m_s, m_u, k_t, plot=False):
    """
    Simulates the response of a quarter-car over different road profiles
    using k_s_opt and c_s_opt the optimized suspension parameters 
    and evaluates ride comfort using ISO 2631 weighting.

    For each road profile the following steps are performed:
    1. Loads GPS-derived road altitude data.
    2. Converts latitude/longitude to metric distance and constructs a smooth,
       time-parametrized road elevation input using spline interpolation.
    3. Simulates the quarter-car dynamics with a time-varying damper
       c(t) = c_s_opt * (1 + 0.1*sin(2πt)) using solve_ivp.
    4. Computes sprung-mass acceleration from the ODE.
    5. Optionally: applies the *time-domain ISO Wk digital filter* for plotting.
       (This is NOT used for optimization.)
    6. Computes the *true comfort metric* using the ISO 2631
       octave-band PSD weighting method. As set out in British Standards
       ISO 2631
    7. Returns the ISO-weighted RMS acceleration for each road.

    Parameters:
    k_s_opt : float
    Optimized suspension stiffness (N/m).
    c_s_opt : float
    Optimized damping coefficient (N·s/m), before time-variation.
    roads : list of dict
        Each dictionary describes a road and must contain:
            {
                "name": str,             # Road label
                "file": str,             # Excel file containing GPS/altitude
                "velocity_mph": float,   # Constant Vehicle speed in mph for 
                "spline_s": float        # Smoothing factor for spline
            }
    m_s : float
    Sprung mass acting on the rear wheel (kg).
    m_u : float
    Unsprung mass acting on the rear wheel (kg).
    k_t : float
    Tire stiffness (N/m).
    plot : bool, optional
        If True:
            - Plots trimmed road profile 
            - Plots weighted and unweighted acceleration for instantaneous time histories
            - Computes the time-domain ISO Wk filtering for visualization only.
        Default is False.

    Returns:
    results : list of dict
        A list containing one dictionary per road, with the fields:
            {
                "road": str,
                "velocity_mph": float,
                "weighted_rms": float,   # ISO-weighted RMS using PSD method
                "comfort_metric": float, # Alias of weighted_rms
                "a_weighted_time": array,# Only if plot=True (ISO filtered)
            }

        - ``weighted_rms`` is the objective used for optimization.
        - Time-domain filtering is NOT used in optimization yet if useful for
        visualisation

    Notes
    The official comfort metric follows ISO 2631 frequency weighting by:
        - computing the PSD of sprung-mass acceleration via Welch,
        - grouping into 1/3-octave bands around ISO reference frequencies,
        - applying ISO weighting factors laid out in BSISO 2631,
        - energy-combining to obtain weighted RMS.

    The damper is modeled with a 10% sinusoidal variation to represent
    environmental and thermal effects: c(t) = c_s_opt * (1 + 0.1 sin(2πt)).

    """
    results=[]
    for road in roads:
        # Read road data
        df = pd.read_excel(road["file"])

        # Convert velocity from mph to m/s
        velocity = road["velocity_mph"] * 0.44704  

        # Extract data
        Latitude = df.iloc[:, 1].values
        Longitude = df.iloc[:, 2].values
        Altitude = df.iloc[:, 3].values

        # Convert degrees to metres
        conversion = 111139
        Latitude = np.array(Latitude) * conversion
        Longitude = np.array(Longitude) * conversion

        # Compute squared differences correctly
        Lat_diffs = np.diff(Latitude)
        Long_diffs = np.diff(Longitude)
        D2 = Lat_diffs**2 + Long_diffs**2
        D = np.sqrt(D2)

        # Cumulative distance (m)
        Dtotal = np.concatenate(([0.0], np.cumsum(D)))

        # Convert from distance to time-domain
        Ttotal = Dtotal / velocity

        # Make x-values for smooth interpolation
        x_lin = np.linspace(Ttotal[0], Ttotal[-1], 700)

        # Interpolation take spline from roads array
        smoothing_factor = road["spline_s"]
        f_lin = interpolate.splrep(Ttotal, Altitude, s=smoothing_factor)
       
        Altitude_smooth = interpolate.splev(x_lin, f_lin, der=0)

        # Normalize road profile so it starts at 0 m
        Altitude_smooth -= Altitude_smooth[0]

        x_r_func = interpolate.interp1d(x_lin, Altitude_smooth, fill_value="extrapolate")
        x_r_dot_func = interpolate.splev(x_lin, f_lin, der=1)

        def x_r(t):
            """
            Returns the road displacement at time t based on the smoothed,
            spline-interpolated road profile.

            Parameters
            t : float or array_like
            Time(s) at which the road elevation is evaluated.

             Returns
            float or ndarray
            Road input displacement x_r(t) in metres.
            """
            return x_r_func(t)

        def x_r_dot(t):
            """
            Returns the road vertical velocity
            by computing the derivative of the interpolated
            altitude signal
            

            Parameters:
            t : float or array_like
            Time(s) at which the road velocity is wanted

            Returns:
            float or ndarray
            Road vertical velocity in metres/s.
            """
            return float(np.interp(t, x_lin, x_r_dot_func))

        t_span = (0, x_lin.max())
        t_space = np.linspace(t_span[0], t_span[1], 1000)

        alpha = 0.1 #10% variation due to environmental changes
        f = 1 #Hz frequency of variation of damping, allows for change every second
        
        def c(t):
            """
            Time-Varying damper model to simulate
            thermal and environmental effects of a real
            world system.
            Where alpha and f are chosen above.
            Parameters:
            t : float or array_like
            Time(s) at which damping coefficient
            is evaluated

            Returns:
            float or ndarray
            Instantaneous damping coefficient in Ns/m
            """
            return c_s_opt * (1 + alpha * np.sin(2 * np.pi * f * t))

        def eom(t, y):
            """
            Equations of motion derived from the Free Body Diagram 
            Rearranged to have acceleration in terms of everything else
            """
            x_s, x_s_dot, x_u, x_u_dot = y 
            xr = x_r(t)
            c_t = c(t)
            x_s_ddot = (1/(m_s)) * (-c_t * (x_s_dot - x_u_dot) - k_s_opt * (x_s - x_u))
            x_u_ddot = (1/m_u) * (c_t * (x_s_dot - x_u_dot) + k_s_opt * (x_s - x_u) - k_t * (x_u - xr))
            return [x_s_dot, x_s_ddot, x_u_dot, x_u_ddot]

        #Intial Condtitions
        y0 = [0, 0, 0, 0]

        # Solve eom using RK45 - closest approximation to RK4 
        sol = solve_ivp(eom, t_span, y0, method='RK45', t_eval=t_space)

        # Extract results
        x_s, x_s_dot, x_u, x_u_dot = sol.y
        
        # Compute accelerations directly from eom
        accels = np.array([eom(t, y) for t, y in zip(sol.t, sol.y.T)])
        x_s_ddot = accels[:, 1]
    
        """
        Trim the first 2.5s of the acceleration data from the graph
        This accounts for the unknown initial conditions which were assumed to be zero
        When starting from t=0s a large change in acceleration was seen as the system 'jumped' into motion
        """
        t_start =2.5  # seconds

        # Find the index where sol.t >= t_start
        idx_start = np.searchsorted(sol.t, t_start)

        # Slice time and corresponding data to remove values befor 2.5s
        t_plot = sol.t[idx_start:]
        x_s_ddot_plot = x_s_ddot[idx_start:]
       
        
        
        fs = 1/np.mean(np.diff(t_plot))
        """
        rms acceleration of sprung mass weighted with frequency of acclerations according to
        iso, if frequencey of sprung mass acceleration lies in sensitive band more weight is given
        to that acceleration value , giving a better evaluation of comfort
        """
        
        if plot:
            # Use digital filter to access instantaneous weighted accelerations
            sections = build_iso_wk(fs)
            a_weighted = x_s_ddot_plot.copy()
            for b, a in sections:
                sos = tf2sos(b, a)
                a_weighted = sosfiltfilt(sos, a_weighted)
            idx_start = np.searchsorted(sol.t, t_start)
            a_weighted_valid = a_weighted[idx_start:]
            a_rms_weighted = np.sqrt(np.mean(a_weighted_valid**2))
            
            # Road Profile Plot (Trimmed)
            plt.figure(figsize=(8,4))
            plt.scatter(Ttotal, Altitude - Altitude[0], s=10, color="red", label="Original Data")
            plt.plot(x_lin, Altitude_smooth, color="blue", label=f"Interpolated Data (Smoothing Factor={smoothing_factor})")
            plt.title(f"{road['name']} - Road Profile")
            plt.xlabel("Time [s]"); plt.ylabel("Relative Displacement [m]")
            plt.grid(True, ls="--", alpha=0.6); plt.legend()
            # Set the x-axis to start at t_start
            plt.xlim(t_start, x_lin[-1]) 
            plt.tight_layout(); plt.show()

            # Acceleration Plot (Trimmed)
            plt.figure(figsize=(10,5))
            # Plot only the data from idx_start onwards
            plt.plot(sol.t[idx_start:], x_s_ddot[idx_start:], label='Unweighted Accel')
            plt.plot(sol.t[idx_start:], a_weighted, label='ISO Wk Weighted Accel', alpha=0.8)
            
            # Plot positive and negative comfort lines
            plt.axhline(0.315, color='g', ls='--', label='Not uncomfortable')
            plt.axhline(-0.315, color='g', ls='--')
            plt.axhline(0.63, color='orange', ls='--', label='A little uncomfortable')
            plt.axhline(-0.63, color='orange', ls='--')
            plt.axhline(1.0, color='r', ls='--', label='Fairly uncomfortable')
            plt.axhline(-1.0, color='r', ls='--')
            
            plt.xlabel("Time [s]"); plt.ylabel("Acceleration [m/s²]")
            plt.title(f"Sprung-Mass Acceleration – {road['name']}")
            plt.legend(); plt.grid(True); plt.tight_layout(); plt.show()

            print(f"=== {road['name']} ===")
            print(f"Weighted RMS (from {t_start}s onwards) = {a_rms_weighted:.3f} m/s² ")
            
        def iso_weighting(x_s_ddot, fs, f_intervals, iso_weights):
            """
            Computes the BSISO 2631 weighted RMS acceleration using the
            1/3-octave-band Power Spectral Density (PSD) and applying offical weightings

           This is the comfort metric used for optimization.

           Steps:
           1. Compute PSD using Welch.
           2. Integrate PSD within each 1/3-octave band centered at f_intervals.
           3. Apply official ISO 2631 weighting factors (iso_weights).
           4. Energy-combine the weighted RMS values.

           Parameters:
           x_s_ddot : ndarray
           Sprung-mass acceleration time series (m/s²).
           fs : float
           Sampling frequency (Hz).
           f_intervals : ndarray
           ISO reference center frequencies for 1/3-octave bands (Hz).
           iso_weights : ndarray
           ISO weighting values x1000

           Returns:
           weighted_overall_rms : float
           ISO 2631 weighted RMS acceleration (m/s²).  
           This is the comfort metric used in the suspension optimization.
           """      
            # Compute psd for x_s_ddot at frequency bins 
            f, psd= welch(x_s_ddot, fs=fs)
            # Compute Spacing between frequencies(Frequency resolution)
            df=f[1]-f[0]
            unweighted_rms=[]
            # Loop for each 1/3 octave center frequency
            for fi in f_intervals:
                #Compute edges of 1/3 octave band
                f1=fi/2**(1/6)#Lower edge
                f2=fi*(2**(1/6))#Upper edge
                #Find indices of frequency bins in this 1/3 octave band
                idx = np.where((f >= f1) & (f <= f2))[0]
                #Compute rms acceleration
                rms = np.sqrt(np.sum(psd[idx]) * df)
                unweighted_rms.append(rms)
            #Convert list to a numpy array    
            unweighted_rms=np.array(unweighted_rms)
            
            #Convert milli weights to proper scale
            W= iso_weights/1000
            #Compute weighted rms as per  BSISO 2631
            weighted_overall_rms = np.sqrt(np.sum((W * unweighted_rms)**2))
           
            return weighted_overall_rms
        
        #Official BSISO 2631 intervals and equivalent weightings
        f_intervals=np.array([0.1, 0.125, 0.16, 0.2, 0.25,
        0.315, 0.4, 0.5, 0.63, 0.8, 1, 1.25, 1.6, 2, 2.5, 3.15, 4, 5, 6.3, 8, 10,
        12.5, 16, 20, 25, 31.5, 40, 50, 63, 80, 100, 125, 160, 200, 250, 315, 400])
       
        iso_weights=np.array([31.2, 48.6, 79.0,
        121, 182, 263, 352, 418, 459, 477, 482, 484, 494, 531, 631, 804, 967, 1039,
        1054, 1036, 988, 902, 768, 636, 513, 405, 314, 246, 186, 132, 80.7, 54.0,
        20.5, 15.2, 7.90, 3.98, 1.95])
       
        rms_iso=iso_weighting(x_s_ddot, fs, f_intervals,iso_weights)

        
      
        #store roads results
        entry={
            "road": road["name"],
            "velocity_mph": road["velocity_mph"],
            "weighted_rms": rms_iso,
            "comfort_metric": rms_iso,   
        }
        if plot:
             entry["a_weighted_time"] = a_weighted  # only defined when plot=True

        results.append(entry)
 

    # Return list of results for all roads
    return results

"""
Optimization loop over reasonable range of target sprung-mass frequencies
(f_targets)  

For each target frequency:
- Compute optimal suspension stiffness (k_s_opt) using k_finder().
- Compute optimal damping coefficient (c_s_opt) using c_finder().
- Evaluate model performance across multiple roads using road_analysis().
- Store results including ISO-weighted RMS acceleration and all road metrics.
"""
#Range of target frequencies    
f_targets = np.linspace(1, 1.6, num=13)

zeta_target = 0.2  # Target damping ratio
results=[]
#Loop for each target frequency
for f_t in f_targets: 
    print(f"\nRunning for f_target={f_t:.2f} Hz")
    #define parameters to be used for analysis
    m_s = 114.436125 #kg mass acting on the rear of the bike (61.5%)
    m_u = 15 #kg mass of rear wheel and tyre 
    k_t = 100000 #N/m rear tyre stiffness
    #Build Mass Matrix for 2DOF system
    M = np.array([[m_s, 0], 
                  [0, m_u]])

    #Find optimal suspension stiffness 
    k_s_opt = k_finder(f_t, m_s, m_u, k_t)
    #Find optimal damping coefficient
    c_s_opt = c_finder(k_s_opt, zeta_target, M, k_t)
     
    #Define roads to evaluate model over
    roads = [
        {"file": os.path.join(base_dir, "Cobbled Road Royal Mile.xlsx"), "name": "Cobbled Road Royal Mile", "velocity_mph": 20, "spline_s": 0.45},
        {"file": os.path.join(base_dir, "Liberton Road (A Road).xlsx"), "name": "Liberton Road (A Road)", "velocity_mph": 30, "spline_s": 0.45},
        {"file": os.path.join(base_dir, "M8 To Glasgow.xlsx"), "name": "M8 To Glasgow", "velocity_mph": 70, "spline_s": 100},
        {"file": os.path.join(base_dir, "EdiBypass.xlsx"), "name": "EdiBypass", "velocity_mph": 70, "spline_s": 100},
        {"file": os.path.join(base_dir, "M90.xlsx"), "name": "M90", "velocity_mph": 70, "spline_s": 100},
        {"file": os.path.join(base_dir, "Pleasance Road (hilly).xlsx"), "name": "Pleasance Road (hilly)", "velocity_mph": 20, "spline_s": 0.45},
        {"file": os.path.join(base_dir, "Queens Drive (Arthurs seat road).xlsx"), "name": "Queens Drive (Arthurs seat road)", "velocity_mph": 30, "spline_s": 0.45},
    ]
        
        # running road simulations to evaluate weighted rms accleration
    road_metrics = road_analysis(k_s_opt, c_s_opt, roads, m_s, m_u, k_t)
    #Compute the average comfort metric across every road defined
    avg_comfort =np.mean ([r["comfort_metric"] for r in road_metrics])
    # Store results for the particular target frequency    
    results.append({
        "f_target": f_t,                   # target sprung-mass frequency
        "zeta_target": zeta_target,        #Target damping ratio
        "k_s_opt": k_s_opt,                #Optimal spring stiffness
        "c_s_opt": c_s_opt,                # Optimal damping coefficient
        "mean_comfort_metric": avg_comfort,# Average weighted RMS across roads
        "road_metrics": road_metrics
        })
  
#Results converted to dataframe for analysis and plotting      
df_results = pd.DataFrame(results)
df_results.to_csv(os.path.join(base_dir, "simulation_results.csv"), index=False)
print("Simulation completed and results saved.")

heatmap_data = df_results.pivot(index="zeta_target", columns="f_target", values="mean_comfort_metric")

# Plot results on heat map 
plt.figure(figsize=(8,6))
plt.imshow(heatmap_data, origin='lower', aspect='auto', cmap='viridis')
plt.colorbar(label='Weighted RMS Acceleration m/s²')
plt.xticks(ticks=np.arange(len(heatmap_data.columns)), labels=np.round(heatmap_data.columns, 2))
plt.yticks(ticks=np.arange(len(heatmap_data.index)), labels=np.round(heatmap_data.index, 2))
plt.xlabel("Target Frequency f [Hz]")
plt.ylabel("Target Damping ζ")
plt.title("Design Sweep Heatmap:Comfort")
plt.show()


# Find design with lowest mean weighted RMS
best_idx = df_results["mean_comfort_metric"].idxmin()
best_design = df_results.loc[best_idx]
best_road_metrics = results[best_idx]["road_metrics"]

print("BEST SUSPENSION DESIGN FOUND")
print(f"Target Frequency (f_target): {best_design['f_target']:.2f} Hz")
print(f"Target Damping Ratio (ζ_target): {best_design['zeta_target']:.2f}")
print(f"Optimal Spring Stiffness (k_s_opt): {best_design['k_s_opt']:.2f} N/m")
print(f"Optimal Damping Coefficient (c_s_opt): {best_design['c_s_opt']:.2f} N·s/m")
print(f"Comfort metric: {best_design['mean_comfort_metric']:.5f} m/s²")
print("="*70)

road_analysis(k_s_opt, c_s_opt, roads, m_s, m_u, k_t, plot=True)

roads_list = [r["road"] for r in best_road_metrics]
rms_vals = [r["weighted_rms"] for r in best_road_metrics]
# Define comfort levels as per BSISO 2631
comfort_levels = []
for rms in rms_vals:
    if rms < 0.315:
        comfort_levels.append("Not uncomfortable")
    elif rms < 0.63:
        comfort_levels.append("A little uncomfortable")
    elif rms < 1.0:
        comfort_levels.append("Fairly uncomfortable")
    elif rms < 1.6:
        comfort_levels.append("Uncomfortable")
    elif rms < 2.5:
        comfort_levels.append("Very uncomfortable")
    else:
        comfort_levels.append("Extremely uncomfortable")

# Plot ISO comfort levels on bar graph for all roads
plt.figure(figsize=(10,5))
bars = plt.bar(roads_list, rms_vals, color='skyblue', edgecolor='black')

# ISO comfort threshold lines 
plt.axhline(0.315, color='g', ls='--', label='Not uncomfortable')
plt.axhline(0.63, color='orange', ls='--', label='A little uncomfortable')
plt.axhline(1.0, color='r', ls='--', label='Fairly uncomfortable')
plt.axhline(1.6, color='m', ls='--', label='Uncomfortable')
plt.axhline(2.5, color='k', ls='--', label='Very uncomfortable')

plt.xticks(rotation=30, ha='right')
plt.ylabel("ISO-weighted RMS Acceleration [m/s²]")
plt.title("ISO 2631 Comfort Comparison Across Roads – Best Suspension Design")
plt.legend()
plt.tight_layout()

# Annotate comfort labels above bars
for bar, txt in zip(bars, comfort_levels):
    plt.text(bar.get_x() + bar.get_width()/2,
             bar.get_height() + 0.05,
             txt,
             ha='center', va='bottom', fontsize=9, rotation=45)

plt.show()



print("\nSummary of All Designs (sorted by comfort ascending)")

# Save heat map data to excel file so optimal k_s and c0 values can easily be found
summary = df_results[["f_target", "k_s_opt", "c_s_opt", "mean_comfort_metric"]].sort_values(
    "mean_comfort_metric")
file_path = os.path.join(os.getcwd(), 'results.xlsx')
summary.to_excel(file_path, index=False)


print(f"File saved at: {file_path}")
print(summary.reset_index(drop=True))
