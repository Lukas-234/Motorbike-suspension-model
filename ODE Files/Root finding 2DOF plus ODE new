import numpy as np
from scipy.linalg import eigh
import matplotlib.pyplot as plt
import os
base_dir = os.path.dirname(os.path.abspath(__file__))
import pandas as pd
from scipy import interpolate
from scipy.integrate import solve_ivp
from scipy.signal import cont2discrete, lfilter, welch, freqz

# System parameters
m_s = 114.436125      # kg, sprung mass (rear portion of scooter)
m_u = 15        # kg, unsprung mass (wheel, swing arm)
k_t = 100000    # N/m, tire stiffness


# Design target: place natural frequency above sensitive range
f_target = 1  # Hz
delta_target=0.3 #for max comfort industry standard

# Mass matrix
M = np.array([[m_s, 0], 
              [0, m_u]])

# Initial guess for k_s bounds using single DOF approximation
k_estimate = (2 * np.pi * f_target)**2 * m_s
k_s_lower = 0.5 * k_estimate
k_s_higher = 2 * k_estimate

# Objective function
def rf_func(k_s):
    """
    Returns: actual_frequency - target_frequency
    Root when this equals zero
    """
    K = np.array([[k_s, -k_s], 
                  [-k_s, k_s + k_t]])
    
    eigenvalues, eigenvectors = eigh(K, M)
    omega_squared = eigenvalues
    omega = np.sqrt(omega_squared)
    freq = omega / (2 * np.pi)
    participations = np.abs(eigenvectors[0,:])  # sprung mass DOF is index 0
    mode_index = np.argmax(participations)      # mode with largest sprung participation
    f_mode = freq[mode_index] # Sprung mass mode (lower frequency)
    
    return f_mode - f_target

# Secant method implementation
k_s_last, k_s_curr = k_s_lower, k_s_higher
F_last, F_curr = rf_func(k_s_last), rf_func(k_s_curr)

max_iterations = 50
tolerance = 1e-4  # Hz

print(f"Initial bounds: k_s ∈ [{k_s_lower:.0f}, {k_s_higher:.0f}] N/m")
print(f"Target frequency: {f_target} Hz Hz\n")

for i in range(max_iterations):
    # Check convergence
    if abs(F_curr) < tolerance:
        print(f"✓ Converged in {i+1} iterations")
        break
    
    # Secant method update
    safe_gd = F_curr - F_last
    if abs(safe_gd) < 1e-12:
        safe_gd = np.sign(safe_gd) * 1e-12
    
    k_s_new = k_s_curr - F_curr * (k_s_curr - k_s_last) / safe_gd
    
    # Ensure positive stiffness
    if k_s_new <= 0:
        k_s_new = 1e-3
    
    # Update for next iteration
    k_s_last, F_last = k_s_curr, F_curr
    k_s_curr, F_curr = k_s_new, rf_func(k_s_new)
    
else:
    print('✗ NO CONVERGENCE')
    
per_spring=k_s_curr*0.5
k_s_opt=k_s_curr

def rf_func2(k_s, c_s):
    K = np.array([[k_s, -k_s],
                  [-k_s, k_s + k_t]])
    C = np.array([[c_s, -c_s],
                  [-c_s, c_s]])
    M_inv = np.linalg.inv(M)
    
    A = np.block([[np.zeros((2,2)), np.eye(2)],
                  [-M_inv @ K, -M_inv @ C]])
    eigvals, eigvecs = np.linalg.eig(A)

# Oneigvals, eigvecs = np.linalg.eig(A)

# Only positive imaginary part (oscillatory)
    pos_idx = [i for i, lam in enumerate(eigvals) if np.imag(lam) > 1e-8]
    
    if len(pos_idx) == 0:
        print(f"[WARNING] No oscillatory eigenvalues for c_s = {c_s:.2f} → overdamped system")
        return 0.0  
    
    eigvals = eigvals[pos_idx]
    eigvecs = eigvecs[:, pos_idx]

# Pick mode with largest sprung-mass participation
    participations = [abs(eigvecs[0,i]) for i in range(len(eigvals))]
    mode_index = np.argmax(participations)
    lam_mode = eigvals[mode_index]

    sigma = np.real(lam_mode)
    omega_d = np.imag(lam_mode)
    delta = -sigma / np.sqrt(sigma**2 + omega_d**2)
    return delta
def objective_func(c_s):
    return rf_func2(k_s_opt, c_s)- delta_target
    

c_lower, c_upper = 500, 1500


c_last, c_curr = c_lower, c_upper
F_last, F_curr = objective_func(c_last), objective_func(c_curr)

max_step=500
for i in range(50):
    if abs(F_curr) < 1e-4:  # Tolerance on damping ratio
        print(f"✓ Converged in {i+1} iterations")
        break
    
    safe_gd = F_curr - F_last
    if abs(safe_gd) < 1e-12:
        safe_gd = np.sign(safe_gd) * 1e-12
    
    c_new = c_curr - F_curr * (c_curr - c_last) / safe_gd
    step = c_new - c_curr
    if abs(step) > max_step:
        step = np.sign(step) * max_step
    c_new = c_curr + step
    
   # Prevent unphysical or NaN values
    if np.isnan(c_new) or np.isinf(c_new):
        print("Warning: secant produced invalid c_s, stopping iteration")
        break
    
    
    c_last, F_last = c_curr, F_curr
    c_curr, F_curr = c_new, objective_func(c_new)

c_s_opt = c_curr
c_s_per_damper = c_s_opt / 2  # Twin shocks

c_s_range = np.linspace(10, 2000, 200)  # range of total damping
delta_vals = [rf_func2(k_s_opt, c) for c in c_s_range]

plt.figure(figsize=(8,5))
plt.plot(c_s_range, delta_vals, label='Sprung-mass modal damping')
plt.axhline(delta_target, color='red', linestyle='--', label=f'Target ζ = {delta_target}')
plt.xlabel('Total damping c_s [N·s/m]')
plt.ylabel('Modal damping ratio ζ')
plt.title('Modal damping ratio vs Total damping')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

print(f"\n{'='*60}")
print(f"Target damping ratio: ζ = {delta_target}")
print(f"Achieved damping ratio: ζ = {delta_target + F_curr:.4f}")
print(f"Total damping: c_s = {c_s_opt:.1f} N·s/m")
print(f"{'='*60}")
    
# Results
print(f"\n{'='*50}")
print(f"Optimal effective spring stiffness: k_s = {k_s_curr:.2f} N/m")
print(f"Optimal per spring stiffness: k_s = {per_spring:.2f} N/m")
print(f"Resulting frequency: {f_target + F_curr:.4f} Hz")
print(f"Target frequency: {f_target:.4f} Hz")
print(f"Final error: {abs(F_curr):.6f} Hz")
print(f"{'='*50}")


# === ISO 2631 Wk filter (Rimell et al., 2007) ===
def build_iso_wk(fs):
    f1, Q1 = 0.4, 0.5
    f2, Q2 = 100.0, 0.5
    f3, f4, Q4 = 12.5, 12.5, 0.63
    f5, Q5, f6, Q6 = 2.37, 0.91, 3.3, 0.91

    w1, w2, w3, w4, w5, w6 = [2*np.pi*f for f in [f1, f2, f3, f4, f5, f6]]
    sections = []

    # High-pass Hh
    num = [1.0, 0.0, 0.0]
    den = [1.0, w1/Q1, w1**2]
    znum, zden, _ = cont2discrete((num, den), 1/fs, method='bilinear')
    sections.append((znum.flatten(), zden.flatten()))

    # Low-pass Hl
    num = [0.0, 0.0, w2**2]
    den = [1.0, w2/Q2, w2**2]
    znum, zden, _ = cont2discrete((num, den), 1/fs, method='bilinear')
    sections.append((znum.flatten(), zden.flatten()))

    # Transition Ht
    num = [0.0, w3, w3*w4]
    den = [1.0, w4, w4**2]
    znum, zden, _ = cont2discrete((num, den), 1/fs, method='bilinear')
    sections.append((znum.flatten(), zden.flatten()))

    # Step Hs
    num = [1.0, w5/Q5, w5**2]
    den = [1.0, w6/Q6, w6**2]
    znum, zden, _ = cont2discrete((num, den), 1/fs, method='bilinear')
    sections.append((znum.flatten(), zden.flatten()))

    return sections

def comfort_classification(a_rms):
    if a_rms < 0.315: return "Not uncomfortable"
    elif a_rms < 0.63: return "A little uncomfortable"
    elif a_rms < 1.0: return "Fairly uncomfortable"
    elif a_rms < 1.6: return "Uncomfortable"
    elif a_rms < 2.5: return "Very uncomfortable"
    else: return "Extremely uncomfortable"

# === Suspension parameters ===
m_s = 114.436125
m_u = 15
k_s = k_s_curr
k_t = 90000
alpha = 0.1
f = 1
g = 9.81  # Gravity constant

# === Roads and speeds ===
# ### NEW ### Added 'spline_s' key for per-road smoothing
roads = [
    {"file": os.path.join(base_dir, "Cobbled Road Royal Mile.xlsx"), "name": "Cobbled Road Royal Mile", "velocity_mph": 20, "spline_s": 0.5},
    {"file": os.path.join(base_dir, "Liberton Road (A Road).xlsx"), "name": "Liberton Road (A Road)", "velocity_mph": 30, "spline_s": 1.0},
    {"file": os.path.join(base_dir, "M8 To Glasgow.xlsx"), "name": "M8 To Glasgow", "velocity_mph": 70, "spline_s": 100.0},
    {"file": os.path.join(base_dir, "Pleasance Road (hilly).xlsx"), "name": "Pleasance Road (hilly)", "velocity_mph": 20, "spline_s": 0.5},
    {"file": os.path.join(base_dir, "Queens Drive (Arthurs seat road).xlsx"), "name": "Queens Drive (Arthurs seat road)", "velocity_mph": 30, "spline_s": 1},
]

results = []

for road in roads:
    print(f"\nProcessing {road['name']}...")
    df = pd.read_excel(road["file"])
    velocity = road["velocity_mph"] * 0.44704

    # --- Original interpolation kept intact ---
    Latitude = df.iloc[:, 1].values
    Longitude = df.iloc[:, 2].values
    Altitude = df.iloc[:, 3].values

    conversion = 111139
    Latitude = np.array(Latitude) * conversion
    Longitude = np.array(Longitude) * conversion

    Lat_diffs = np.diff(Latitude)
    Long_diffs = np.diff(Longitude)
    D2 = Lat_diffs**2 + Long_diffs**2
    D = np.sqrt(D2)
    Dtotal = np.concatenate(([0.0], np.cumsum(D)))
    Ttotal = Dtotal / velocity

    x_lin = np.linspace(Ttotal[0], Ttotal[-1], 700)
    
    # ### NEW ### Use the per-road smoothing factor
    smoothing_factor = road["spline_s"]
    print(f"Using smoothing factor s={smoothing_factor}")
    f_lin = interpolate.splrep(Ttotal, Altitude, s=smoothing_factor)
    # ### END NEW ###
    
    Altitude_smooth = interpolate.splev(x_lin, f_lin, der=0)
    Altitude_smooth -= Altitude_smooth[0] # Normalize profile to start at 0

    x_r_func = interpolate.interp1d(x_lin, Altitude_smooth, fill_value="extrapolate")
    x_r_dot_func = interpolate.splev(x_lin, f_lin, der=1)

    def x_r(t): return x_r_func(t)
    def x_r_dot(t): return float(np.interp(t, x_lin, x_r_dot_func))

    # --- ODE system ---
    t_span = (0, x_lin.max())
    t_space = np.linspace(t_span[0], t_span[1], 1000)
    c0 = c_s_opt
    def c(t): return c0 * (1 + alpha * np.sin(2*np.pi*f*t))
    def eom(t, y):
        x_s, x_s_dot, x_u, x_u_dot = y
        xr = x_r(t)
        ct = c(t)
        x_s_ddot = (1/m_s)*(-ct*(x_s_dot - x_u_dot) - k_s*(x_s - x_u))
        x_u_ddot = (1/m_u)*(ct*(x_s_dot - x_u_dot) + k_s*(x_s - x_u) - k_t*(x_u - xr))
        return [x_s_dot, x_s_ddot, x_u_dot, x_u_ddot]

    # --- Quasi-static equilibrium initial conditions ---
    x_r0 = x_r(0)
    x_r_dot0 = x_r_dot(0)
    x_u0 = x_r0 + (m_u * g) / k_t
    x_s0 = x_u0 + (m_s * g) / k_s
    x_u_dot0 = x_r_dot0
    x_s_dot0 = x_r_dot0
    y0 = [x_s0, x_s_dot0, x_u0, x_u_dot0]

    # --- Solve ODE ---
    sol = solve_ivp(eom, t_span, y0, t_eval=t_space, method='RK45')
    
    x_s, x_s_dot, x_u, x_u_dot = sol.y
    accels = np.array([eom(t, y) for t, y in zip(sol.t, sol.y.T)])
    x_s_ddot = accels[:, 1]

    # === Apply ISO 2631 weighting ===
    fs = 1 / np.mean(np.diff(sol.t))
    sections = build_iso_wk(fs)
    a_weighted = x_s_ddot.copy()
    for b, a in sections:
        a_weighted = lfilter(b, a, a_weighted)

    # --- Optional: trim 1.0s transient from start for RMS ---
    t_start = 1.0  # Time to ignore (in seconds)
    try:
        idx_start = np.searchsorted(sol.t, t_start)
        a_weighted_valid = a_weighted[idx_start:]
        
        if len(a_weighted_valid) == 0:
            print(f"Warning: Trimming at {t_start}s left no data. Using all data.")
            a_weighted_valid = a_weighted
            idx_start = 0 # Reset index if trimming failed
            
    except Exception as e:
        print(f"Warning: Trimming failed ({e}). Using all data.")
        a_weighted_valid = a_weighted
        idx_start = 0 # Reset index if trimming failed

    a_rms_weighted = np.sqrt(np.mean(a_weighted_valid**2))
    
    comfort = comfort_classification(a_rms_weighted)
    results.append({"Road": road["name"], "RMS": a_rms_weighted, "Comfort": comfort})

    # === Plots ===
    
    # --- Road Profile Plot (Trimmed) ---
    plt.figure(figsize=(8,4))
    plt.scatter(Ttotal, Altitude - Altitude[0], s=10, color="red", label="Original")
    plt.plot(x_lin, Altitude_smooth, color="blue", label=f"Spline (s={smoothing_factor})")
    plt.title(f"{road['name']} – Road Profile (Trimmed from {t_start}s)")
    plt.xlabel("Time [s]"); plt.ylabel("Relative Displacement [m]")
    plt.grid(True, ls="--", alpha=0.6); plt.legend()
    # Set the x-axis to start at t_start
    plt.xlim(t_start, x_lin[-1]) 
    plt.tight_layout(); plt.show()

    # --- Acceleration Plot (Trimmed) ---
    plt.figure(figsize=(10,5))
    # Plot only the data from idx_start onwards
    plt.plot(sol.t[idx_start:], x_s_ddot[idx_start:], label='Unweighted Accel')
    plt.plot(sol.t[idx_start:], a_weighted[idx_start:], label='ISO Wk Weighted Accel', alpha=0.8)
    
    # Plot positive and negative comfort lines
    plt.axhline(0.315, color='g', ls='--', label='Not uncomfortable')
    plt.axhline(-0.315, color='g', ls='--')
    plt.axhline(0.63, color='orange', ls='--', label='A little uncomfortable')
    plt.axhline(-0.63, color='orange', ls='--')
    plt.axhline(1.0, color='r', ls='--', label='Fairly uncomfortable')
    plt.axhline(-1.0, color='r', ls='--')
    
    plt.xlabel("Time [s]"); plt.ylabel("Acceleration [m/s²]")
    plt.title(f"Sprung-Mass Acceleration – {road['name']} (Trimmed from {t_start}s)")
    plt.legend(); plt.grid(True); plt.tight_layout(); plt.show()

    print(f"=== {road['name']} ===")
    print(f"Weighted RMS (from {t_start}s onwards) = {a_rms_weighted:.3f} m/s² → {comfort}")

    # === Frequency analysis & Wk curve comparison ===
    f_psd, Pxx = welch(x_s_ddot, fs=fs, nperseg=2024)
    dominant_freq = f_psd[np.argmax(Pxx)]
    print(f"Dominant vibration frequency ≈ {dominant_freq:.2f} Hz")

    # Build Wk magnitude curve
    w, h = freqz([1], [1], worN=2000, fs=fs)
    for b, a in sections:
        _, h_temp = freqz(b, a, worN=w, fs=fs)
        h *= h_temp


# === Summary bar chart across roads ===
roads_list = [r["Road"] for r in results]
rms_vals = [r["RMS"] for r in results]
comfort_levels = [r["Comfort"] for r in results]

plt.figure(figsize=(10,5))
bars = plt.bar(roads_list, rms_vals, color='skyblue', edgecolor='black')
# Plot all levels for a consistent scale
plt.axhline(0.315, color='g', ls='--', label='Not uncomfortable')
plt.axhline(0.63, color='orange', ls='--', label='A little uncomfortable')
plt.axhline(1.0, color='r', ls='--', label='Fairly uncomfortable')
plt.axhline(1.6, color='m', ls='--', label='Uncomfortable')
plt.axhline(2.5, color='k', ls='--', label='Very uncomfortable')
plt.xticks(rotation=30, ha='right')
plt.ylabel("Weighted RMS Acceleration [m/s²]")
plt.title("ISO 2631 Comfort Comparison Across Roads")
plt.legend(); plt.tight_layout()
for bar, txt in zip(bars, comfort_levels):
    plt.text(bar.get_x() + bar.get_width()/2, bar.get_height()+0.05, txt,
             ha='center', va='bottom', fontsize=9, rotation=45)
plt.show()
