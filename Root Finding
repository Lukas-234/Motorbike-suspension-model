import numpy as np

# --- constants (rear 1-DOF) ---
m_s = 181.0          # sprung mass [kg]
k_t = 90_000.0       # tyre stiffness [N/m]

f_target    = 2.5   # Hz: target ride frequency (for tuning k_s)
zeta_target = 0.90   # optional: target damping ratio (to show root-find on c)

# --- equivalent stiffness and frequency ---
def k_eq(ks):
    # series combination of k_s and k_t
    return (ks * k_t) / (ks + k_t)

def f_low(ks):
    # lowest natural frequency for 1-DOF
    if ks <= 0: return -1e9
    return (1.0/(2*np.pi)) * np.sqrt(k_eq(ks)/m_s)

# --- residuals ---
def r1(ks):                 # hit target frequency
    return f_low(ks) - f_target

def c_crit(ks):             # critical damping for the tuned 1-DOF
    return 2.0*np.sqrt(m_s * k_eq(ks))

def r2(c, ks_fixed):        # optional: hit target damping ratio
    return (c / c_crit(ks_fixed)) - zeta_target

# --- bisection (for ks) ---
def bisection(f, a, b, tol=1e-4, itmax=60):
    fa, fb = f(a), f(b)
    if not np.isfinite(fa) or not np.isfinite(fb) or fa*fb > 0:
        raise RuntimeError(f"Need sign change: f({a})={fa:.3g}, f({b})={fb:.3g}")
    for _ in range(itmax):
        m  = 0.5*(a+b)
        fm = f(m)
        if abs(fm) < tol or abs(b-a) < tol:
            return m
        if fa*fm < 0: b, fb = m, fm
        else:         a, fa = m, fm
    return 0.5*(a+b)

# --- Newton (tiny, for c or ks if you want) ---
def newton(f, x0, tol=1e-6, itmax=25):
    x = float(x0)
    for _ in range(itmax):
        fx = f(x)
        if abs(fx) < tol: return x
        h  = 1e-6*max(1.0, abs(x))
        dfx = (f(x+h)-f(x-h))/(2*h)
        if dfx == 0 or not np.isfinite(dfx): break
        x_new = x - fx/dfx
        if abs(x_new - x) < tol: return x_new
        x = x_new
    return x

# ================= run =================
if __name__ == "__main__":
    # 1) root-find k_s by bisection to hit f_target
    ks_lo, ks_hi = 30_000.0, 300_000.0   # a broad, physical bracket
    ks_star = bisection(r1, ks_lo, ks_hi, tol=1e-3)

    # 2) compute critical damping at that k_s (transition point)
    ccrit = c_crit(ks_star)

    # (optional) 3) show root-finding for c to match a zeta_target
    #    – this is trivial here (closed form), but we demonstrate Newton/bisection usage.
    # closed-form answer: c_target = zeta_target * ccrit
    c_target_closed = zeta_target * ccrit

    # do it with Newton anyway (on r2)
    c0 = ccrit  # sensible starting point
    c_target_newton = newton(lambda c: r2(c, ks_star), c0, tol=1e-6)

    print(f"k_s (bisection) = {ks_star:,.1f} N/m")
    print(f"f_low(ks*)      = {f_low(ks_star):.3f} Hz (target {f_target:.3f} Hz)")
    print(f"c_crit(ks*)     = {ccrit:,.1f} N·s/m  (oscillatory ↔ overdamped transition)")

    print(f"c_target (closed-form, zeta={zeta_target:.2f}) = {c_target_closed:,.1f} N·s/m")
    print(f"c_target (Newton on r2)                        = {c_target_newton:,.1f} N·s/m")
