import numpy as np
from scipy.linalg import eigh
import os
base_dir = os.path.dirname(os.path.abspath(__file__))
import matplotlib.pyplot as plt
import pandas as pd
from scipy import interpolate
from scipy.integrate import solve_ivp
from scipy.signal import cont2discrete, welch, freqz, sosfiltfilt, tf2sos

# === ISO 2631 Wk filter (Rimell et al., 2007) ===
def build_iso_wk(fs):
    f1, Q1 = 0.4, 0.5
    f2, Q2 = 100.0, 0.5
    f3, f4, Q4 = 12.5, 12.5, 0.63
    f5, Q5, f6, Q6 = 2.37, 0.91, 3.3, 0.91

    w1, w2, w3, w4, w5, w6 = [2*np.pi*f for f in [f1, f2, f3, f4, f5, f6]]
    sections = []

    # High-pass Hh
    num = [1.0, 0.0, 0.0]
    den = [1.0, w1/Q1, w1**2]
    znum, zden, _ = cont2discrete((num, den), 1/fs, method='bilinear')
    sections.append((znum.flatten(), zden.flatten()))

    # Low-pass Hl
    num = [0.0, 0.0, w2**2]
    den = [1.0, w2/Q2, w2**2]
    znum, zden, _ = cont2discrete((num, den), 1/fs, method='bilinear')
    sections.append((znum.flatten(), zden.flatten()))

    # Transition Ht
    num = [0.0, w3, w3*w4]
    den = [1.0, w4, w4**2]
    znum, zden, _ = cont2discrete((num, den), 1/fs, method='bilinear')
    sections.append((znum.flatten(), zden.flatten()))

    # Step Hs
    num = [1.0, w5/Q5, w5**2]
    den = [1.0, w6/Q6, w6**2]
    znum, zden, _ = cont2discrete((num, den), 1/fs, method='bilinear')
    sections.append((znum.flatten(), zden.flatten()))

    return sections
def comfort_classification(a_rms):
    if a_rms < 0.315: return "Not uncomfortable"
    elif a_rms < 0.63: return "A little uncomfortable"
    elif a_rms < 1.0: return "Fairly uncomfortable"
    elif a_rms < 1.6: return "Uncomfortable"
    elif a_rms < 2.5: return "Very uncomfortable"
    else: return "Extremely uncomfortable"
    
def k_finder(f_target, m_s, m_u, k_t):
    m_total=m_u+m_s
    k_estimate = (2 * np.pi * f_target)**2 * m_total
    k_s_lower = 0.5 * k_estimate
    k_s_higher = 2 * k_estimate
    def rf_func(k_s):
        """
        Returns: actual_frequency - target_frequency
        Root when this equals zero
        """
        K = np.array([[k_s, -k_s], 
                      [-k_s, k_s + k_t]])
        M = np.array([[m_s, 0], 
                      [0, m_u]])
        
        eigenvalues, eigenvectors = eigh(K, M)
        omega_squared = eigenvalues
        omega = np.sqrt(omega_squared)
        freq = omega / (2 * np.pi)
        participations = np.abs(eigenvectors[0,:])  # sprung mass DOF is index 0
        mode_index = np.argmax(participations)      # mode with largest sprung participation
        f_mode = freq[mode_index] # Sprung mass mode (lower frequency)
        
        return f_mode - f_target

    # Secant method implementation
    k_s_last, k_s_curr = k_s_lower, k_s_higher
    F_last, F_curr = rf_func(k_s_last), rf_func(k_s_curr)

    max_iterations = 50
    tolerance = 1e-4  # Hz

 #   print(f"Target frequency: {f_target} Hz Hz\n")

    for i in range(max_iterations):
        # Check convergence
        if abs(F_curr) < tolerance:
          #  print(f"found k in {i+1} iterations")
            break
        
        # Secant method update
        safe_gd = F_curr - F_last
        if abs(safe_gd) < 1e-12:
            safe_gd = np.sign(safe_gd) * 1e-12
        
        k_s_new = k_s_curr - F_curr * (k_s_curr - k_s_last) / safe_gd
        
        # Ensure positive stiffness
        if k_s_new <= 0:
            k_s_new = 1e-3
        
        # Update for next iteration
        k_s_last, F_last = k_s_curr, F_curr
        k_s_curr, F_curr = k_s_new, rf_func(k_s_new)
        
    else:
        print('✗ NO CONVERGENCE')
    k_s_opt=k_s_curr
   # print(f"k_s_opt={k_s_opt:.2f} N/m")
    return k_s_opt
def c_finder(k_opt, delta_target, M, k_t):
    def rf_func2(k_s, c_s):
        K = np.array([[k_s, -k_s],
                      [-k_s, k_s + k_t]])
        C = np.array([[c_s, -c_s],
                      [-c_s, c_s]])
        M_inv = np.linalg.inv(M)
        
        A = np.block([[np.zeros((2,2)), np.eye(2)],
                      [-M_inv @ K, -M_inv @ C]])
        eigvals, eigvecs = np.linalg.eig(A)
        n_sprung = 1
        
        participations = []
        for i in range(eigvecs.shape[1]):
            # Only consider the position entries for sprung mass
            P = np.sum(np.abs(eigvecs[0:n_sprung, i]))
            participations.append(P)
        
        # --- Step 2: pick mode with largest sprung mass participation ---
        if len(participations) == 0:
            # Fallback if no modes found
            return 0.0
        mode_index = np.argmax(participations)
        lam_mode = eigvals[mode_index]
        
        # --- Step 3: compute modal damping ---
        sigma = np.real(lam_mode)
        omega_d = np.imag(lam_mode)
        
        # Avoid division by zero
        if np.isclose(sigma**2 + omega_d**2, 0.0):
            delta = 0.0
        else:
            delta = -sigma / np.sqrt(sigma**2 + omega_d**2)
        return delta

    def objective_func(c_s):
        return rf_func2(k_s_opt, c_s)- delta_target
        

    c_lower, c_upper = 500, 1500


    c_last, c_curr = c_lower, c_upper
    F_last, F_curr = objective_func(c_last), objective_func(c_curr)

    max_step=500
    for i in range(50):
        if abs(F_curr) < 1e-4:  # Tolerance on damping ratio
           # print(f"✓ found c in {i+1} iterations")
            break
        
        safe_gd = F_curr - F_last
        if abs(safe_gd) < 1e-12:
            safe_gd = np.sign(safe_gd) * 1e-12
        
        c_new = c_curr - F_curr * (c_curr - c_last) / safe_gd
        step = c_new - c_curr
        if abs(step) > max_step:
            step = np.sign(step) * max_step
        c_new = c_curr + step
        
       # Prevent unphysical or NaN values
        if np.isnan(c_new) or np.isinf(c_new):
            print("Warning: secant produced invalid c_s, stopping iteration")
            break
        
        
        c_last, F_last = c_curr, F_curr
        c_curr, F_curr = c_new, objective_func(c_new)

    c_s_opt = c_curr
    return c_s_opt

def road_analysis(k_s_opt, c_s_opt, roads, m_s, m_u, k_t, plot=False):
    results=[]
    for road in roads:
        # === Cobbled Road Royal Mile ===
        df = pd.read_excel(road["file"])

        # velocity in m/s
        velocity = road["velocity_mph"] * 0.44704  

        # Extract data
        Latitude = df.iloc[:, 1].values
        Longitude = df.iloc[:, 2].values
        Altitude = df.iloc[:, 3].values

        # Convert degrees to meters
        conversion = 111139
        Latitude = np.array(Latitude) * conversion
        Longitude = np.array(Longitude) * conversion

        # Compute squared differences correctly
        Lat_diffs = np.diff(Latitude)
        Long_diffs = np.diff(Longitude)
        D2 = Lat_diffs**2 + Long_diffs**2
        D = np.sqrt(D2)

        # Cumulative distance (m)
        Dtotal = np.concatenate(([0.0], np.cumsum(D)))

        # Time = distance / velocity
        Ttotal = Dtotal / velocity

        # Make x-values for smooth interpolation
        x_lin = np.linspace(Ttotal[0], Ttotal[-1], 700)

        # Interpolation (set small smoothing for realistic curve)
       # Interpolation (set small smoothing for realistic curve)
        smoothing_factor = road["spline_s"]
        #print(f"Using smoothing factor s={smoothing_factor}")
        f_lin = interpolate.splrep(Ttotal, Altitude, s=smoothing_factor)
       
        Altitude_smooth = interpolate.splev(x_lin, f_lin, der=0)

        # Normalize road profile so it starts at 0 m
        Altitude_smooth -= Altitude_smooth[0]

        x_r_func = interpolate.interp1d(x_lin, Altitude_smooth, fill_value="extrapolate")
        x_r_dot_func = interpolate.splev(x_lin, f_lin, der=1)

        def x_r(t):
            return x_r_func(t)

        def x_r_dot(t):
            return float(np.interp(t, x_lin, x_r_dot_func))

        t_span = (0, x_lin.max())
        t_space = np.linspace(t_span[0], t_span[1], 1000)

        alpha = 0.1 #10% variation due to environmental changes
        f = 1 #Hz frequency of variation of damping, allows for change every second
        
        def c(t):
            return c_s_opt * (1 + alpha * np.sin(2 * np.pi * f * t))

        def eom(t, y):
            x_s, x_s_dot, x_u, x_u_dot = y 
            xr = x_r(t)
            c_t = c(t)
            x_s_ddot = (1/(m_s)) * (-c_t * (x_s_dot - x_u_dot) - k_s_opt * (x_s - x_u))
            x_u_ddot = (1/m_u) * (c_t * (x_s_dot - x_u_dot) + k_s_opt * (x_s - x_u) - k_t * (x_u - xr))
            return [x_s_dot, x_s_ddot, x_u_dot, x_u_ddot]

        #Intial Condtitions to be changed [x_s, x_s_dot, x_u, x_u_dot]
        y0 = [0, 0, 0, 0]

        sol = solve_ivp(eom, t_span, y0, method='RK45', t_eval=t_space)

        # Extract results
        x_s, x_s_dot, x_u, x_u_dot = sol.y
        x_rp = x_r(sol.t)

        # Compute accelerations directly from eom()
        # (This ensures they are derived from the same ODE, not rederived manually)
        accels = np.array([eom(t, y) for t, y in zip(sol.t, sol.y.T)])
        x_s_ddot = accels[:, 1]
        x_u_ddot = accels[:, 3]
    
        
        t_start =2.5  # seconds

        # Find the index where sol.t >= t_start
        idx_start = np.searchsorted(sol.t, t_start)

        # Slice time and corresponding data
        t_plot = sol.t[idx_start:]
        x_s_ddot_plot = x_s_ddot[idx_start:]
       
        
        
        fs = 1/np.mean(np.diff(t_plot))
        "rms acceleration of sprung mass weighted with frequency of acclerations according to"
        "iso, if frequencey of sprung mass acceleration lies in sensitive band more weight is given"
        "to that acceleration value , giving a better evaluation of comfort"
        
        if plot:
            #use digital filter to access instantaneous weighted accelerations
            sections = build_iso_wk(fs)
            a_weighted = x_s_ddot_plot.copy()
            for b, a in sections:
                sos = tf2sos(b, a)             # convert to SOS
                a_weighted = sosfiltfilt(sos, a_weighted)
            idx_start = np.searchsorted(sol.t, t_start)
            a_weighted_valid = a_weighted[idx_start:]
            a_rms_weighted = np.sqrt(np.mean(a_weighted_valid**2))
            
            # --- Road Profile Plot (Trimmed) ---
            plt.figure(figsize=(8,4))
            plt.scatter(Ttotal, Altitude - Altitude[0], s=10, color="red", label="Original")
            plt.plot(x_lin, Altitude_smooth, color="blue", label=f"Spline (s={smoothing_factor})")
            plt.title(f"{road['name']} – Road Profile (Trimmed from {t_start}s)")
            plt.xlabel("Time [s]"); plt.ylabel("Relative Displacement [m]")
            plt.grid(True, ls="--", alpha=0.6); plt.legend()
            # Set the x-axis to start at t_start
            plt.xlim(t_start, x_lin[-1]) 
            plt.tight_layout(); plt.show()

            # --- Acceleration Plot (Trimmed) ---
            plt.figure(figsize=(10,5))
            # Plot only the data from idx_start onwards
            plt.plot(sol.t[idx_start:], x_s_ddot[idx_start:], label='Unweighted Accel')
            plt.plot(sol.t[idx_start:], a_weighted, label='ISO Wk Weighted Accel', alpha=0.8)
            
            # Plot positive and negative comfort lines
            plt.axhline(0.315, color='g', ls='--', label='Not uncomfortable')
            plt.axhline(-0.315, color='g', ls='--')
            plt.axhline(0.63, color='orange', ls='--', label='A little uncomfortable')
            plt.axhline(-0.63, color='orange', ls='--')
            plt.axhline(1.0, color='r', ls='--', label='Fairly uncomfortable')
            plt.axhline(-1.0, color='r', ls='--')
            
            plt.xlabel("Time [s]"); plt.ylabel("Acceleration [m/s²]")
            plt.title(f"Sprung-Mass Acceleration – {road['name']} (Trimmed from {t_start}s)")
            plt.legend(); plt.grid(True); plt.tight_layout(); plt.show()

            print(f"=== {road['name']} ===")
            print(f"Weighted RMS (from {t_start}s onwards) = {a_rms_weighted:.3f} m/s² ")
            
        def iso_weighting(x_s_ddot, fs, f_intervals, iso_weights):
            f, psd= welch(x_s_ddot, fs=fs)
            df=f[1]-f[0]
            unweighted_rms=[]
            for fi in f_intervals:
                f1=fi/2**(1/6)
                f2=fi*(2**(1/6))
                idx = np.where((f >= f1) & (f <= f2))[0]
                rms = np.sqrt(np.sum(psd[idx]) * df)
                unweighted_rms.append(rms)
            unweighted_rms=np.array(unweighted_rms)
           
            W= iso_weights/1000
            weighted_overall_rms = np.sqrt(np.sum((W * unweighted_rms)**2))
           
            return weighted_overall_rms
        f_intervals=np.array([0.1, 0.125, 0.16, 0.2, 0.25,
        0.315, 0.4, 0.5, 0.63, 0.8, 1, 1.25, 1.6, 2, 2.5, 3.15, 4, 5, 6.3, 8, 10,
        12.5, 16, 20, 25, 31.5, 40, 50, 63, 80, 100, 125, 160, 200, 250, 315, 400])
       
        iso_weights=np.array([31.2, 48.6, 79.0,
        121, 182, 263, 352, 418, 459, 477, 482, 484, 494, 531, 631, 804, 967, 1039,
        1054, 1036, 988, 902, 768, 636, 513, 405, 314, 246, 186, 132, 80.7, 54.0,
        20.5, 15.2, 7.90, 3.98, 1.95])
       
        rms_iso=iso_weighting(x_s_ddot, fs, f_intervals,iso_weights)

# Primary comfort objective is still the ISO-weighted RMS acceleration
# (Optionally normalize by rms_ref so values are order-of-one)
        
      

        entry={
            "road": road["name"],
            "velocity_mph": road["velocity_mph"],
            "weighted_rms": rms_iso,
            "comfort_metric": rms_iso,   # use same key for both plotting & analysis
        }
        if plot:
             entry["a_weighted_time"] = a_weighted  # only defined when plot=True

        results.append(entry)
 

    # Return list of results for all roads
    return results

    
f_targets = np.array([0.9,1.0,1.1,1.2,1.3,1.5,1.6,1.8,2.0])        # Hz
delta_target = 0.25  # damping ratios
results=[]
for f_t in f_targets: 
    print(f"\nRunning for f_target={f_t:.2f} Hz, ζ_target={delta_target:.2f}")
    m_s = 113.54 #kg mass acting on the rear of the bike (61.5%)
    m_u = 15 #kg mass of rear wheel and tyre 
    k_t = 100000 #N/m rear tyre stiffness
    M = np.array([[m_s, 0], 
                  [0, m_u]])


    k_s_opt = k_finder(f_t, m_s, m_u, k_t)
    c_s_opt = c_finder(k_s_opt, delta_target, M, k_t)
        
    roads = [
        {"file": os.path.join(base_dir, "Cobbled Road Royal Mile.xlsx"), "name": "Cobbled Road Royal Mile", "velocity_mph": 20, "spline_s": 0.4},
        {"file": os.path.join(base_dir, "Liberton Road (A Road).xlsx"), "name": "Liberton Road (A Road)", "velocity_mph": 30, "spline_s": 0.4},
        {"file": os.path.join(base_dir, "M8 To Glasgow.xlsx"), "name": "M8 To Glasgow", "velocity_mph": 70, "spline_s": 40},
        {"file": os.path.join(base_dir, "Pleasance Road (hilly).xlsx"), "name": "Pleasance Road (hilly)", "velocity_mph": 20, "spline_s": 0.4},
        {"file": os.path.join(base_dir, "Queens Drive (Arthurs seat road).xlsx"), "name": "Queens Drive (Arthurs seat road)", "velocity_mph": 30, "spline_s": 0.4},
       # {"file": os.path.join(base_dir, "Redford Road (B Road).xlsx"), "name": "Redford Road (B Road)", "velocity_mph": 30, "spline_s": 0.1}
    ]
        
        # running road simulations to evaluate weighted rms accleration
    road_metrics = road_analysis(k_s_opt, c_s_opt, roads, m_s, m_u, k_t)
    avg_comfort =np.mean ([r["comfort_metric"] for r in road_metrics])
        
    results.append({
        "f_target": f_t,
        "zeta_target": delta_target,
        "k_s_opt": k_s_opt,
        "c_s_opt": c_s_opt,
        "mean_comfort_metric": avg_comfort,
        "road_metrics": road_metrics
        })
        
df_results = pd.DataFrame(results)

heatmap_data = df_results.pivot(index="zeta_target", columns="f_target", values="mean_comfort_metric")

plt.figure(figsize=(8,6))
# Use imshow
plt.imshow(heatmap_data, origin='lower', aspect='auto', cmap='viridis')
plt.colorbar(label='Mean Comfort Metric ')
plt.xticks(ticks=np.arange(len(heatmap_data.columns)), labels=np.round(heatmap_data.columns, 2))
plt.yticks(ticks=np.arange(len(heatmap_data.index)), labels=np.round(heatmap_data.index, 2))
plt.xlabel("Target Frequency f [Hz]")
plt.ylabel("Target Damping ζ")
plt.title("Design Sweep Heatmap:Comfort Metric")
plt.show()

#%%
# Find design with lowest mean weighted RMS
best_idx = df_results["mean_comfort_metric"].idxmin()
best_design = df_results.loc[best_idx]
best_road_metrics = results[best_idx]["road_metrics"]

print("BEST SUSPENSION DESIGN FOUND")
print(f"Target Frequency (f_target): {best_design['f_target']:.2f} Hz")
print(f"Target Damping Ratio (ζ_target): {best_design['zeta_target']:.2f}")
print(f"Optimal Spring Stiffness (k_s_opt): {best_design['k_s_opt']:.2f} N/m")
print(f"Optimal Damping Coefficient (c_s_opt): {best_design['c_s_opt']:.2f} N·s/m")
print(f"Comfort metric: {best_design['mean_comfort_metric']:.5f} m/s²")
print("="*70)

road_analysis(k_s_opt, c_s_opt, roads, m_s, m_u, k_t, plot=True)

roads_list = [r["road"] for r in best_road_metrics]
rms_vals = [r["weighted_rms"] for r in best_road_metrics]
comfort_levels = []
for rms in rms_vals:
    if rms < 0.315:
        comfort_levels.append("Not uncomfortable")
    elif rms < 0.63:
        comfort_levels.append("A little uncomfortable")
    elif rms < 1.0:
        comfort_levels.append("Fairly uncomfortable")
    elif rms < 1.6:
        comfort_levels.append("Uncomfortable")
    elif rms < 2.5:
        comfort_levels.append("Very uncomfortable")
    else:
        comfort_levels.append("Extremely uncomfortable")

# === Plot ISO comfort levels ===
plt.figure(figsize=(10,5))
bars = plt.bar(roads_list, rms_vals, color='skyblue', edgecolor='black')

# ISO comfort thresholds
plt.axhline(0.315, color='g', ls='--', label='Not uncomfortable')
plt.axhline(0.63, color='orange', ls='--', label='A little uncomfortable')
plt.axhline(1.0, color='r', ls='--', label='Fairly uncomfortable')
plt.axhline(1.6, color='m', ls='--', label='Uncomfortable')
plt.axhline(2.5, color='k', ls='--', label='Very uncomfortable')

plt.xticks(rotation=30, ha='right')
plt.ylabel("ISO-weighted RMS Acceleration [m/s²]")
plt.title("ISO 2631 Comfort Comparison Across Roads – Best Suspension Design")
plt.legend()
plt.tight_layout()

# Annotate comfort labels above bars
for bar, txt in zip(bars, comfort_levels):
    plt.text(bar.get_x() + bar.get_width()/2,
             bar.get_height() + 0.05,
             txt,
             ha='center', va='bottom', fontsize=9, rotation=45)

plt.show()


print("\nAll designs sorted by comfort (ascending comfort metric):")
print(df_results.sort_values("mean_comfort_metric").reset_index(drop=True)) 
